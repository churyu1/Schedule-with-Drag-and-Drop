[
  {
    "id": 78,
    "author": "user",
    "payload": {
      "type": "text",
      "text": "現在 画面右下に行追加ボタンがあります｡\nこれと同じ 行追加ボタンを ｢プロジェクト終了日｣の右隣にも設置してください｡",
      "files": [],
      "fileUploads": [],
      "cssBlocks": [],
      "cMarkNode": {}
    },
    "createdTimestamp": {
      "seconds": 1770605210,
      "nanos": 683000000
    }
  },
  {
    "id": 79,
    "author": "model",
    "payload": {
      "type": "thinking",
      "text": "**Locating Component Placement**\n\nI'm currently focused on pinpointing the exact location of the \"Project End Date\" field within the `GanttChart` component's header. This is the first step toward figuring out where to place the new \"Add Task\" button, a design element the user would like to add. I'm exploring the component's structure to gain the necessary context.\n\n\n**Analyzing Component Structure**\n\nI've located the `GanttChart.tsx` component and identified the specific header section. Within the code, I see a `div` element with a grid layout, specifically `grid-cols-1 md:grid-cols-2`. This contains project details, including the \"Project End Date\". The header's structure uses a grid. The first row spans both columns on medium screens and up. I'm now examining the positioning of the \"Project End Date\" field within this grid, as it is key to positioning the new button.\n\n\n**Evaluating Grid Implications**\n\nI've been analyzing the implications of adding the \"Add Task\" button next to \"Project End Date\" within the grid layout. Currently, \"Project End Date\" is the last element in a row with \"Project Start Date\". I'm considering grid behavior. Options include adding the button as a sibling element, but this could cause wrapping, or adding a new column to the grid, which would also result in a row wrap. The ideal placement needs careful consideration of how the grid will render.\n\n\n**Considering Layout Options**\n\nI'm now weighing placement strategies. The 2-column grid presents challenges for a new \"Add Task\" button, particularly to meet the \"right next to\" visual requirement. I'm focusing on alternatives, I'm now exploring whether to alter the grid itself, or embed the button within the \"Project End Date\" container, perhaps using absolute positioning or flexbox to manage the new input wrapper. I've re-examined the component's markup to assess its adaptability, looking at the layout around the \"Project End Date\" input, and its calendar toggle.\n\n\n**Refining Grid Structure**\n\nI'm now iterating on the grid modification. Rather than a flex container, I'm considering adding the \"Add Task\" button as a new element within the existing grid structure. I'm exploring the implications of adding a new item within that arrangement and determining the best way to modify the columns for the appropriate visual effect. I need to make sure the original grid doesn't break.\n\n\n**Implementing Flex Containers**\n\nI'm now iterating on a flex container approach. I've decided on an inline flex container within the grid. The \"Project End Date\" and the new \"Add Task\" button will share the same container and maintain their inline arrangement. This should keep the layout clean and not disrupt the other grid components. I've updated the JSX with this approach. The goal is to avoid the column wrap.\n\n\n**Confirming Styling Consistency**\n\nI've decided on an inline flex container within the grid to hold both the \"Project End Date\" and the \"Add Task\" button, and I've updated the JSX. Now, I'm checking the button's styling. The user wanted the \"Add Task\" button to match the bottom-right button's style. I've located the styling for that button and will apply it.\n\n\n**Interpreting \"Same\" Request**\n\nI'm now interpreting the user's \"same\" request for the \"Add Task\" button. I'm focusing on \"same functionality and visual style\" (blue circle with plus) but scaling the button size to match the header context. A large, floating button (w-14 h-14) is likely too large inline. I'm aiming for a square, inline button that complements the adjacent input field's height to maintain visual harmony.\n\n\n**Refining Button Aesthetics**\n\nI'm now refining the aesthetics of the \"Add Task\" button. I've considered that a large FAB is bad design in this form header context. The goal is to make the new button match the form input's height, while keeping the circular or rounded-square style and color scheme of the other button. I am leaning toward a slightly smaller size, perhaps w-10 h-10 or w-11 h-11, to best match the existing input height. I need a button that fits nicely!\n\n\n\n**Confirming Grid Integration**\n\nI've confirmed the grid integration. By wrapping the \"Project End Date\" and the new \"Add Task\" button within a `div`, that `div` now takes up the second column slot in the grid, as intended. This placement keeps the header layout clean. I'm satisfied.\n\n\n**Verifying File Content**\n\nI'm now checking the content of `components/GanttChart.tsx`, and I've found the target code block, which includes the project end date input and calendar icon button. I'm verifying the input and calendar button, within the code I've been working with, and confirming it is the right place to add the new button.\n\n\n**Refining Input Height**\n\nI'm now refining the integration of the \"Add Task\" button with the existing input field in the GanttChart header. After inspecting the rendering, I see a small visual mismatch. The ideal button size aligns with the input's vertical padding and border. After considering the dimensions and font size of the input field, I'm leaning toward using `h-11`, which is the best fit. I've re-checked the style guide and code.\n\n\n**Adjusting Button Sizing**\n\nI'm now iterating on button sizing within the GanttChart header. After inspecting the existing input's height (around 40-42px) and the `text-base` font size, I'm considering using `h-10 w-10` for the \"Add Task\" button, or `p-2` with a rounded-full style. I'll maintain the FAB style (indigo background, white text, shadow) but scale it down to fit, to maintain balance.\n\n\n**Finalizing Button Placement**\n\nI'm now implementing the final button placement within the GanttChart header. After inspecting the existing code I've decided on `h-10 w-10` for the \"Add Task\" button, and have confirmed that the new button is now in-line and adjacent to the project end date, within the established flex container. I am reviewing the styling, and the intended size appears correct!\n\n\n**Verifying Bottom Alignment**\n\nI'm now focusing on aligning the \"Add Task\" button with the bottom of the input container. After adding the button, I noticed they were not perfectly aligned. My current approach includes a `mb-[2px]` on the button, and `items-end` to handle the vertical positioning. I'm verifying the input height and the impact of the `items-end` flex container attribute. I'll need to check the input wrapper, since the input itself is probably bottom-aligned within a wrapper.\n\n```\n                  <button\n                  onClick={onAddTask}\n                  title={t('addTask')}\n                  className=\"mb-[2px] w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all transform hover:scale-105\"\n                  >\n                  <PlusIcon className=\"w-6 h-6\" />\n                  </button>\n```\nI've checked the height of the elements. I'm thinking the input *container* or wrapper will align with the button. The input has no bottom margin. The label has `mb-1`. The `flex-grow` div inside has no margin on its bottom.\n\n\n**Refining Final Alignment**\n\nI'm now making the final adjustments for button alignment. My latest revision includes removing `mb-[2px]` from the button itself and adding `items-baseline` to the flex container, which provides a more consistent vertical alignment between the button and input. I am checking the rendered output. This is now correct!\n\n\n\n**Confirming Targeted Files**\n\nI'm now focusing on ensuring I'm modifying the correct files. After double-checking the project setup and the `index.html` file, I've confirmed that the primary file to update is `components/GanttChart.tsx`, since this file is rendered by the root module. The `.js` files seem to be transpiled, so updating the `.tsx` file should be sufficient. I am confident I am updating the right code.\n\n\n",
      "cMarkNode": {}
    },
    "createdTimestamp": {
      "seconds": 1770605210,
      "nanos": 683000000
    },
    "doneTimestamp": {
      "seconds": 1770605261,
      "nanos": 149000000
    }
  },
  {
    "id": 80,
    "author": "model",
    "payload": {
      "type": "generationTable",
      "entries": [
        {
          "path": "components/GanttChart.tsx",
          "generationType": 1,
          "isDone": true,
          "description": "Add \"Add Task\" button next to Project End Date",
          "diffs": [
            {
              "target": "",
              "replacement": "import React, { useState, useMemo, useCallback, useEffect, useRef } from 'react';\nimport type { Task } from '../types.ts';\nimport PlusIcon from './icons/PlusIcon.tsx';\nimport TrashIcon from './icons/TrashIcon.tsx';\nimport CalendarIcon from './icons/CalendarIcon.tsx';\nimport Calendar from './Calendar.tsx';\nimport { useLanguage } from '../contexts/LanguageContext.tsx';\nimport { translations, TranslationKey } from '../lib/translations.ts';\nimport GripVerticalIcon from './icons/GripVerticalIcon.tsx';\nimport DuplicateIcon from './icons/DuplicateIcon.tsx';\nimport { \n    parseUTCDateString, \n    formatDateUTC, \n    addDaysUTC, \n    getDatesInRange,\n    calculateWorkingDays,\n} from '../lib/dateUtils.ts';\n\n\nconst ZOOM_LEVELS = [8, 12, 18, 24, 40, 64];\n\ntype DragActionType = 'move' | 'resize-start' | 'resize-end';\n\nconst getReactEventCoords = (e: React.MouseEvent | React.TouchEvent) => {\n    if ('touches' in e) {\n        return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };\n    }\n    return { clientX: e.clientX, clientY: e.clientY };\n};\n\nconst getNativeEventCoords = (e: MouseEvent | TouchEvent) => {\n    if (e.type.startsWith('touch')) {\n        const touch = (e as TouchEvent).touches[0] || (e as TouchEvent).changedTouches[0];\n        if (touch) {\n            return { clientX: touch.clientX, clientY: touch.clientY };\n        }\n    }\n    const mouseEvent = e as MouseEvent;\n    return { clientX: mouseEvent.clientX, clientY: mouseEvent.clientY };\n};\n\ninterface GanttChartProps {\n  projectName: string;\n  setProjectName: React.Dispatch<React.SetStateAction<string>>;\n  projectStart: string;\n  setProjectStart: React.Dispatch<React.SetStateAction<string>>;\n  projectEnd: string;\n  setProjectEnd: React.Dispatch<React.SetStateAction<string>>;\n  creationDate: string;\n  setCreationDate: React.Dispatch<React.SetStateAction<string>>;\n  creatorName: string;\n  setCreatorName: React.Dispatch<React.SetStateAction<string>>;\n  tasks: Task[];\n  holidays: Set<number>;\n  columnVisibility: {\n    assignee: boolean;\n    startDate: boolean;\n    endDate: boolean;\n    duration: boolean;\n    progress: boolean;\n    manHours: boolean;\n  };\n  zoomIndex: number;\n  progressLineDate: string | null;\n  baseColor: string;\n  progressColor: string;\n  textColor: string;\n  progressLineColor: string;\n  rowHeight: number;\n  onDeleteAllTasks: () => void;\n  onAddTask: () => void;\n  onDeleteTask: (id: string) => void;\n  onDuplicateTask: (id: string) => void;\n  onTaskChange: (id: string, field: keyof Task, value: string | number | undefined) => void;\n  onDurationChange: (task: Task, newDurationStr: string) => void;\n  onProgressChange: (taskId: string, newProgressStr: string) => void;\n  onManHoursChange: (taskId: string, newManHoursStr: string) => void;\n  onTaskDateSet: (taskId: string, startDate: string, endDate: string) => void;\n  onTaskDragUpdate: (\n    taskId: string,\n    actionType: DragActionType,\n    initialStartDate: Date,\n    initialEndDate: Date,\n    dayOffset: number\n  ) => void;\n  onTaskReorder: (draggedTaskId: string, dropIndex: number) => void;\n}\n\nconst GanttChart: React.FC<GanttChartProps> = ({\n  projectName,\n  setProjectName,\n  projectStart,\n  setProjectStart,\n  projectEnd,\n  setProjectEnd,\n  creationDate,\n  setCreationDate,\n  creatorName,\n  setCreatorName,\n  tasks,\n  holidays,\n  columnVisibility,\n  zoomIndex,\n  progressLineDate,\n  baseColor,\n  progressColor,\n  textColor,\n  progressLineColor,\n  rowHeight,\n  onDeleteAllTasks,\n  onAddTask,\n  onDeleteTask,\n  onDuplicateTask,\n  onTaskChange,\n  onDurationChange,\n  onProgressChange,\n  onManHoursChange,\n  onTaskDateSet,\n  onTaskDragUpdate,\n  onTaskReorder,\n}) => {\n  const { language } = useLanguage();\n  const t = useCallback((key: TranslationKey) => {\n    return translations[key][language];\n  }, [language]);\n\n  const [activeCalendar, setActiveCalendar] = useState<{ type: string; taskId?: string, position: 'top' | 'bottom' } | null>(null);\n  \n  const timelineHeaderRef = useRef<HTMLDivElement>(null);\n  const scrollContainerRef = useRef<HTMLDivElement>(null);\n  const taskRowRefs = useRef<{ [key: string]: HTMLDivElement | null }>({});\n  const taskDetailsHeaderRef = useRef<HTMLDivElement>(null);\n  const ganttGridRef = useRef<HTMLDivElement>(null);\n\n  const [dragPreview, setDragPreview] = useState<{ taskId: string; start: string; end: string; } | null>(null);\n  const [tooltip, setTooltip] = useState<{ visible: boolean; x: number; y: number; content: string } | null>(null);\n  \n  const [dragAction, setDragAction] = useState<{\n    type: DragActionType;\n    taskId: string;\n    initialX: number;\n    initialStartDate: Date;\n    initialEndDate: Date;\n  } | null>(null);\n\n  const [reorderState, setReorderState] = useState<{ draggedTaskId: string; dropIndex: number | null } | null>(null);\n  const [totalGridWidth, setTotalGridWidth] = useState(0);\n\n  const handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n    e.target.select();\n  };\n\n  useEffect(() => {\n    const gridElement = ganttGridRef.current;\n    if (gridElement) {\n        const observer = new ResizeObserver((entries) => {\n            if (entries[0]) {\n                setTotalGridWidth(entries[0].target.scrollWidth);\n            }\n        });\n        observer.observe(gridElement);\n        return () => {\n            if (gridElement) {\n                observer.unobserve(gridElement);\n            }\n        };\n    }\n  }, []);\n\n  const dayWidth = useMemo(() => ZOOM_LEVELS[zoomIndex], [zoomIndex]);\n\n  const openCalendar = useCallback((e: React.MouseEvent, type: string, taskId?: string) => {\n    // Per user request, force task-related calendars to always open downwards.\n    if (type === 'taskStartDate' || type === 'taskEndDate') {\n      setActiveCalendar(prev => {\n        const isActive = prev?.type === type && prev?.taskId === taskId;\n        return isActive ? null : { type, taskId, position: 'bottom' };\n      });\n      return;\n    }\n    \n    // For other calendars (project header), use dynamic positioning to avoid clipping.\n    const button = e.currentTarget;\n    const buttonRect = button.getBoundingClientRect();\n    const viewportHeight = window.innerHeight;\n    const spaceBelow = viewportHeight - buttonRect.bottom;\n    const spaceAbove = buttonRect.top;\n    const calendarHeight = 320; // Estimated height of the calendar popover\n\n    let position: 'top' | 'bottom' = 'bottom'; // Default to bottom\n\n    // Prioritize opening downwards if there's enough space.\n    if (spaceBelow >= calendarHeight) {\n        position = 'bottom';\n    } \n    // Otherwise, try opening upwards if there's enough space.\n    else if (spaceAbove >= calendarHeight) {\n        position = 'top';\n    } \n    // If not enough space either way, open where there is more space to minimize clipping.\n    else if (spaceAbove > spaceBelow) {\n        position = 'top';\n    }\n    \n    setActiveCalendar(prev => {\n        const isActive = prev?.type === type && prev?.taskId === taskId;\n        return isActive ? null : { type, taskId, position };\n    });\n  }, []);\n  \n  useEffect(() => {\n    if (!activeCalendar) return;\n\n    const handleClickOutside = (event: MouseEvent) => {\n        if (!(event.target as HTMLElement).closest('[data-calendar-popover]') && !(event.target as HTMLElement).closest('[data-calendar-toggle]')) {\n             setActiveCalendar(null);\n        }\n    };\n    \n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n        document.removeEventListener('mousedown', handleClickOutside);\n    };\n}, [activeCalendar]);\n\n    useEffect(() => {\n        // Ensure refs are cleaned up to prevent memory leaks\n        const taskIds = new Set(tasks.map(t => t.id));\n        Object.keys(taskRowRefs.current).forEach(taskId => {\n            if (!taskIds.has(taskId)) {\n                delete taskRowRefs.current[taskId];\n            }\n        });\n    }, [tasks]);\n\n  const dateArray = useMemo(() => {\n    const start = parseUTCDateString(projectStart);\n    const end = parseUTCDateString(projectEnd);\n    if (!start || !end || start > end) return [];\n    return getDatesInRange(start, end);\n  }, [projectStart, projectEnd]);\n\n  const getTaskDuration = useCallback((startDateStr: string, endDateStr: string): number => {\n    const start = parseUTCDateString(startDateStr);\n    const end = parseUTCDateString(endDateStr);\n    if (!start || !end) return 0;\n    return calculateWorkingDays(start, end, holidays);\n  }, [holidays]);\n    \n  const getGridPosition = (start: Date, end: Date) => {\n    if (dateArray.length === 0 || end < start) return { gridColumn: '1 / span 1', opacity: 0 };\n\n    const projectStartDate = dateArray[0];\n    const projectEndDate = dateArray[dateArray.length - 1];\n\n    // Find the intersection of the task and project timelines for rendering\n    const renderStart = new Date(Math.max(start.getTime(), projectStartDate.getTime()));\n    const renderEnd = new Date(Math.min(end.getTime(), projectEndDate.getTime()));\n\n    // If there is no intersection, the task is not visible\n    if (renderEnd < renderStart) {\n      return { gridColumn: '1 / span 1', opacity: 0 };\n    }\n\n    const startIndex = dateArray.findIndex(d => d.getTime() === renderStart.getTime());\n    const endIndex = dateArray.findIndex(d => d.getTime() === renderEnd.getTime());\n    \n    if (startIndex === -1 || endIndex === -1) {\n       return { gridColumn: '1 / span 1', opacity: 0 };\n    }\n    \n    return { gridColumn: `${startIndex + 1} / ${endIndex + 2}` };\n  };\n  \n  const getTaskSegments = useCallback((task: Task): {startDate: Date, endDate: Date}[] => {\n    const start = parseUTCDateString(task.startDate);\n    const end = parseUTCDateString(task.endDate);\n    if (!start || !end || end < start) return [];\n\n    const segments: {startDate: Date, endDate: Date}[] = [];\n    let segmentStart: Date | null = null;\n    \n    const current = new Date(start.getTime());\n    while(current.getTime() <= end.getTime()){\n      const isHoliday = holidays.has(current.getUTCDay());\n      \n      if(!isHoliday && segmentStart === null){\n        segmentStart = new Date(current.getTime());\n      } else if(isHoliday && segmentStart !== null){\n        const segmentEnd = new Date(current.getTime());\n        segmentEnd.setUTCDate(segmentEnd.getUTCDate() - 1);\n        segments.push({startDate: segmentStart, endDate: segmentEnd});\n        segmentStart = null;\n      }\n      current.setUTCDate(current.getUTCDate() + 1);\n    }\n    \n    if (segmentStart !== null) {\n      segments.push({startDate: segmentStart, endDate: end});\n    }\n\n    return segments;\n  }, [holidays]);\n\n  const monthHeaders = useMemo(() => {\n    const months: { formatted: string; days: number }[] = [];\n    if (dateArray.length === 0) return months;\n\n    let currentMonth = -1;\n    let currentYear = -1;\n\n    dateArray.forEach(date => {\n        const month = date.getUTCMonth();\n        const year = date.getUTCFullYear();\n        if (month !== currentMonth || year !== currentYear) {\n            currentMonth = month;\n            currentYear = year;\n            const formattedString = date.toLocaleString(language === 'ja' ? 'ja-JP' : 'en-US', {\n                year: 'numeric',\n                month: 'long',\n                timeZone: 'UTC',\n            });\n            months.push({ formatted: formattedString, days: 0 });\n        }\n        months[months.length - 1].days++;\n    });\n    return months;\n  }, [dateArray, language]);\n\n  const dateHeaders = useMemo(() => {\n    if (dateArray.length === 0) return [];\n\n    let interval = 1;\n    if (dayWidth < 24) interval = 2;\n    if (dayWidth < 18) interval = 3;\n    if (dayWidth < 12) interval = 7;\n\n    const headers = [];\n    for (let i = 0; i < dateArray.length; i += interval) {\n      const date = dateArray[i];\n      const remainingDays = dateArray.length - i;\n      const span = Math.min(interval, remainingDays);\n      \n      const lastDayInSpan = dateArray[i + span - 1];\n      const dayAfterLast = addDaysUTC(lastDayInSpan, 1);\n      const isLastDayOfMonth = dayAfterLast.getUTCDate() === 1;\n\n      headers.push({\n        date,\n        span,\n        isLastDayOfMonth,\n      });\n    }\n    return headers;\n  }, [dateArray, dayWidth]);\n\n  const getDateFromX = useCallback((x: number) => {\n    // This implementation calculates the position relative to the main grid element,\n    // which correctly accounts for horizontal scrolling.\n    if (!ganttGridRef.current || !taskDetailsHeaderRef.current || dateArray.length === 0) return null;\n\n    const gridRect = ganttGridRef.current.getBoundingClientRect();\n    const detailsWidth = taskDetailsHeaderRef.current.offsetWidth;\n    \n    // The timeline starts visually after the task details column.\n    // The absolute left position of the timeline content's start.\n    const timelineStartLeft = gridRect.left + detailsWidth;\n\n    // The mouse position relative to the beginning of the timeline content.\n    const relativeX = x - timelineStartLeft;\n\n    if (dayWidth <= 0 || relativeX < 0) return null;\n\n    const dateIndex = Math.floor(relativeX / dayWidth);\n\n    if (dateIndex >= 0 && dateIndex < dateArray.length) {\n        return dateArray[dateIndex];\n    }\n    return null;\n  }, [dateArray, dayWidth]);\n\n const handlePointerDownForCreate = useCallback((e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n      if (e.type.startsWith('touch')) {\n        e.preventDefault();\n      }\n      const { clientX } = getReactEventCoords(e);\n      const startDate = getDateFromX(clientX);\n      if (startDate) {\n          if (holidays.has(startDate.getUTCDay())) {\n            // Prevent task creation on holidays\n            return;\n          }\n          const taskId = (e.currentTarget as HTMLElement).dataset.taskRowId;\n          if (taskId) {\n            const startDateStr = formatDateUTC(startDate);\n            setDragPreview({ taskId, start: startDateStr, end: startDateStr });\n          }\n      }\n      setTooltip(null);\n  }, [getDateFromX, holidays]);\n\n  const handlePointerMove = useCallback((e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n    const timelineRowCell = e.currentTarget;\n    const { clientX, clientY } = getReactEventCoords(e);\n\n    // Handle active drag preview update\n    if(dragPreview) {\n        if (e.type === 'touchmove') e.preventDefault(); // Prevent scrolling\n        const currentDate = getDateFromX(clientX);\n        if (currentDate) {\n            setDragPreview(prev => (prev ? { ...prev, end: formatDateUTC(currentDate) } : null));\n        }\n        return; // Don't do cursor/tooltip logic while actively creating a task\n    }\n\n    if (e.type.startsWith('touch') || dragAction || reorderState) {\n        setTooltip(null);\n        return;\n    }\n    \n    // Mouse-only logic for cursor and tooltip\n    const taskId = timelineRowCell.dataset.taskRowId;\n    const task = tasks.find(t => t.id === taskId);\n\n    if (task && !task.startDate && !task.endDate) {\n        const dateUnderCursor = getDateFromX(clientX);\n        const isHolidayUnderCursor = dateUnderCursor ? holidays.has(dateUnderCursor.getUTCDay()) : true;\n\n        if (isHolidayUnderCursor) {\n            timelineRowCell.style.cursor = 'not-allowed';\n            setTooltip(null);\n        } else {\n            timelineRowCell.style.cursor = 'crosshair';\n            setTooltip({\n                visible: true,\n                x: clientX,\n                y: clientY,\n                content: t('dragToSetDuration'),\n            });\n        }\n    } else {\n        timelineRowCell.style.cursor = 'default';\n        setTooltip(null);\n    }\n  }, [dragPreview, dragAction, reorderState, tasks, getDateFromX, holidays, t]);\n  \n  const handleMouseLeave = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    // Reset cursor and tooltip when mouse leaves the row\n    e.currentTarget.style.cursor = 'default';\n    setTooltip(null);\n  }, []);\n\n  useEffect(() => {\n    if (!dragPreview) return;\n\n    const handlePointerUpGlobal = () => {\n        if (dragPreview) {\n            onTaskDateSet(dragPreview.taskId, dragPreview.start, dragPreview.end);\n            setDragPreview(null);\n        }\n    };\n\n    window.addEventListener('mouseup', handlePointerUpGlobal);\n    window.addEventListener('touchend', handlePointerUpGlobal);\n    return () => {\n        window.removeEventListener('mouseup', handlePointerUpGlobal);\n        window.removeEventListener('touchend', handlePointerUpGlobal);\n    };\n  }, [dragPreview, onTaskDateSet]);\n\n  const handleDragStart = useCallback((e: React.MouseEvent | React.TouchEvent, task: Task, type: DragActionType) => {\n    if (e.type.startsWith('touch')) {\n        e.preventDefault();\n    }\n    e.stopPropagation();\n    const start = parseUTCDateString(task.startDate);\n    const end = parseUTCDateString(task.endDate);\n    if (!start || !end) return;\n\n    const { clientX } = getReactEventCoords(e);\n\n    setDragAction({\n      type,\n      taskId: task.id,\n      initialX: clientX,\n      initialStartDate: start,\n      initialEndDate: end,\n    });\n  }, []);\n\n  const handleDragMove = useCallback((e: MouseEvent | TouchEvent) => {\n    if (e.type === 'touchmove') {\n        e.preventDefault();\n    }\n    if (!dragAction) return;\n    if (dayWidth <= 0) return;\n\n    const coords = getNativeEventCoords(e);\n    if (!coords) return;\n    const { clientX } = coords;\n\n    const deltaX = clientX - dragAction.initialX;\n    const dayOffset = Math.round(deltaX / dayWidth);\n\n    onTaskDragUpdate(\n        dragAction.taskId,\n        dragAction.type,\n        dragAction.initialStartDate,\n        dragAction.initialEndDate,\n        dayOffset\n    );\n\n    // If resizing causes start/end to flip, update the drag action type\n    const task = tasks.find(t => t.id === dragAction.taskId);\n    if (task) {\n        const newStart = parseUTCDateString(task.startDate);\n        const newEnd = parseUTCDateString(task.endDate);\n        if (newStart && newEnd && newStart > newEnd) {\n            if (dragAction.type === 'resize-start') {\n                setDragAction(prev => (prev ? { ...prev, type: 'resize-end' } : null));\n            } else if (dragAction.type === 'resize-end') {\n                setDragAction(prev => (prev ? { ...prev, type: 'resize-start' } : null));\n            }\n        }\n    }\n  }, [dragAction, dayWidth, onTaskDragUpdate, tasks]);\n\n  const handleDragEnd = useCallback(() => {\n    setDragAction(null);\n  }, []);\n  \n  useEffect(() => {\n    const getCursor = (type: DragActionType) => {\n      switch (type) {\n        case 'move': return 'grabbing';\n        case 'resize-start':\n        case 'resize-end': return 'ew-resize';\n        default: return 'auto';\n      }\n    };\n    \n    if (dragAction) {\n        document.body.style.cursor = getCursor(dragAction.type);\n        document.body.style.userSelect = 'none';\n        window.addEventListener('mousemove', handleDragMove);\n        window.addEventListener('touchmove', handleDragMove, { passive: false });\n        window.addEventListener('mouseup', handleDragEnd);\n        window.addEventListener('touchend', handleDragEnd);\n    }\n\n    return () => {\n        window.removeEventListener('mousemove', handleDragMove);\n        window.removeEventListener('touchmove', handleDragMove);\n        window.removeEventListener('mouseup', handleDragEnd);\n        window.removeEventListener('touchend', handleDragEnd);\n        if (document.body) {\n           document.body.style.cursor = 'auto';\n           document.body.style.userSelect = 'auto';\n        }\n    };\n  }, [dragAction, handleDragMove, handleDragEnd]);\n\n\n  const handleReorderStart = useCallback((e: React.MouseEvent | React.TouchEvent, taskId: string) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setReorderState({ draggedTaskId: taskId, dropIndex: null });\n  }, []);\n\n  const handleReorderMove = useCallback((e: MouseEvent | TouchEvent) => {\n    if (e.type === 'touchmove') {\n        e.preventDefault();\n    }\n    if (!reorderState) return;\n\n    const coords = getNativeEventCoords(e);\n    if (!coords) return;\n    const { clientY } = coords;\n\n    const positions = tasks.map(task => {\n        const el = taskRowRefs.current[task.id];\n        if (!el) return { id: task.id, top: -1, bottom: -1, mid: -1 };\n        const rect = el.getBoundingClientRect();\n        return { id: task.id, top: rect.top, bottom: rect.bottom, mid: rect.top + rect.height / 2 };\n    }).filter(p => p.top !== -1);\n\n    const target = positions.find(p => clientY >= p.top && clientY <= p.bottom);\n    let newDropIndex: number | null = null;\n    if (target) {\n        const targetIndex = tasks.findIndex(t => t.id === target.id);\n        newDropIndex = clientY < target.mid ? targetIndex : targetIndex + 1;\n    } else {\n        const firstTaskRect = taskRowRefs.current[tasks[0]?.id]?.getBoundingClientRect();\n        if (firstTaskRect && clientY < firstTaskRect.top) {\n            newDropIndex = 0;\n        } else {\n            const lastTaskRect = taskRowRefs.current[tasks[tasks.length-1]?.id]?.getBoundingClientRect();\n            if(lastTaskRect && clientY > lastTaskRect.bottom) {\n                 newDropIndex = tasks.length;\n            }\n        }\n    }\n    \n    setReorderState(prev => (prev ? { ...prev, dropIndex: newDropIndex } : null));\n  }, [reorderState, tasks]);\n\n  const handleReorderEnd = useCallback(() => {\n    if (reorderState && typeof reorderState.dropIndex === 'number') {\n        onTaskReorder(reorderState.draggedTaskId, reorderState.dropIndex);\n    }\n    setReorderState(null);\n  }, [reorderState, onTaskReorder]);\n\n  useEffect(() => {\n    if (reorderState?.draggedTaskId) {\n        document.body.style.cursor = 'grabbing';\n        document.body.style.userSelect = 'none';\n        window.addEventListener('mousemove', handleReorderMove);\n        window.addEventListener('touchmove', handleReorderMove, { passive: false });\n        window.addEventListener('mouseup', handleReorderEnd);\n        window.addEventListener('touchend', handleReorderEnd);\n    }\n    return () => {\n        window.removeEventListener('mousemove', handleReorderMove);\n        window.removeEventListener('touchmove', handleReorderMove);\n        window.removeEventListener('mouseup', handleReorderEnd);\n        window.removeEventListener('touchend', handleReorderEnd);\n        if (document.body) {\n           document.body.style.cursor = 'auto';\n           document.body.style.userSelect = 'auto';\n        }\n    };\n  }, [reorderState, handleReorderMove, handleReorderEnd]);\n\n  const dropIndex = reorderState?.dropIndex;\n\n  const progressLinePath = useMemo(() => {\n    if (!progressLineDate || dateArray.length === 0 || !taskDetailsHeaderRef.current || !timelineHeaderRef.current) return null;\n\n    const headerHeight = timelineHeaderRef.current.offsetHeight;\n    const taskDetailsWidth = taskDetailsHeaderRef.current.offsetWidth || 0;\n    const baselineDate = parseUTCDateString(progressLineDate);\n    if (!baselineDate) return null;\n\n    const baselineDateIndex = dateArray.findIndex(d => d.getTime() === baselineDate.getTime());\n    if (baselineDateIndex === -1) return null;\n\n    const baselineX = (baselineDateIndex + 1) * dayWidth;\n\n    const taskProgressXs = tasks.map(task => {\n        let currentTaskX = baselineX; // Default to baseline\n\n        const startDate = parseUTCDateString(task.startDate);\n        const endDate = parseUTCDateString(task.endDate);\n\n        if (startDate && endDate) {\n            const isCompletedEarly = endDate.getTime() < baselineDate.getTime() && task.progress === 100;\n            const isNotYetStarted = startDate.getTime() > baselineDate.getTime() && task.progress === 0;\n\n            if (!isCompletedEarly && !isNotYetStarted) {\n                const totalWorkDays = calculateWorkingDays(startDate, endDate, holidays);\n                if (totalWorkDays > 0) {\n                    let completedWorkDays = totalWorkDays * (task.progress / 100);\n                    \n                    let currentPosDate = new Date(startDate.getTime());\n                    let pixelOffset = 0;\n\n                    while(completedWorkDays > 0 && currentPosDate.getTime() <= endDate.getTime()) {\n                        if(!holidays.has(currentPosDate.getUTCDay())){\n                           const consumption = Math.min(1, completedWorkDays);\n                           pixelOffset += consumption * dayWidth;\n                           completedWorkDays -= consumption;\n                        } else {\n                           pixelOffset += dayWidth;\n                        }\n                        \n                        if (completedWorkDays > 0) {\n                          currentPosDate.setUTCDate(currentPosDate.getUTCDate() + 1);\n                        }\n                    }\n                    const startIndex = dateArray.findIndex(d => d.getTime() === startDate.getTime());\n                    if(startIndex !== -1) {\n                        currentTaskX = (startIndex * dayWidth) + pixelOffset;\n                    }\n                }\n            }\n        }\n        return taskDetailsWidth + currentTaskX;\n    });\n\n    const taskBarHeight = 32; // Corresponds to h-8 in Tailwind\n    const spaceAboveBelowBar = (rowHeight - taskBarHeight) / 2;\n    const finalBaselineX = taskDetailsWidth + baselineX;\n\n    // Start with a vertical line through the timeline header.\n    let path = `M ${finalBaselineX} 0 L ${finalBaselineX} ${headerHeight}`;\n    \n    if (tasks.length > 0 && taskProgressXs.length > 0) {\n        tasks.forEach((_, i) => {\n            const progressX = taskProgressXs[i];\n            const rowTopY = headerHeight + i * rowHeight;\n            const barTopY = rowTopY + spaceAboveBelowBar;\n            const barCenterY = rowTopY + rowHeight / 2;\n            const barBottomY = rowTopY + rowHeight - spaceAboveBelowBar;\n            const rowBottomY = rowTopY + rowHeight;\n            \n            // From previous point (or header) to the top of the task bar at baseline\n            path += ` L ${finalBaselineX} ${barTopY}`;\n            \n            // To the actual progress point at the center of the bar\n            path += ` L ${progressX} ${barCenterY}`;\n            \n            // Back to the baseline at the bottom of the bar\n            path += ` L ${finalBaselineX} ${barBottomY}`;\n            \n            // And finally down to the bottom of the row at baseline, to connect to the next task\n            path += ` L ${finalBaselineX} ${rowBottomY}`;\n        });\n    }\n\n    return path;\n  }, [progressLineDate, tasks, dateArray, dayWidth, holidays, rowHeight]);\n  \n  const totalContentHeight = (timelineHeaderRef.current?.offsetHeight || 0) + tasks.length * rowHeight;\n\n  const totalManHours = useMemo(() => {\n    return tasks.reduce((sum, task) => sum + (task.manHours || 0), 0);\n  }, [tasks]);\n\n  return (\n    <div className=\"bg-white rounded-lg shadow-lg flex flex-col max-h-[calc(100vh-16rem)] sm:max-h-[calc(100vh-14rem)]\">\n      {tooltip?.visible && (\n        <div\n            className=\"fixed bg-gray-800 text-white text-xs rounded py-1 px-2 pointer-events-none shadow-lg\"\n            style={{\n                top: tooltip.y + 20,\n                left: tooltip.x + 15,\n                zIndex: 1000,\n            }}\n        >\n            {tooltip.content}\n        </div>\n      )}\n      <div className=\"p-4 sm:p-6 flex-shrink-0 border-b\">\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 items-end\">\n          {/* Combined Row 1: Project Name, Creation Date, Creator */}\n          <div className=\"md:col-span-2 flex flex-wrap items-end gap-x-4 gap-y-2\">\n            {/* Project Name */}\n            <div className=\"flex-grow min-w-[300px]\">\n              <label htmlFor=\"projectName\" className=\"block text-sm font-medium text-gray-700 mb-1\">{t('projectNameLabel')}</label>\n              <input\n                type=\"text\"\n                id=\"projectName\"\n                value={projectName}\n                onChange={e => setProjectName(e.target.value)}\n                onFocus={handleInputFocus}\n                placeholder={t('projectNamePlaceholder')}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-base font-semibold focus:outline-none focus:ring-indigo-500 focus:border-indigo-500\"\n              />\n            </div>\n\n            {/* Creation Date */}\n            <div className=\"relative w-36 flex-shrink-0\">\n              <label htmlFor=\"creationDate\" className=\"block text-sm font-medium text-gray-700 mb-1\">{t('creationDate')}</label>\n              <div className=\"relative\">\n                <input type=\"text\" id=\"creationDate\" value={creationDate} onChange={e => setCreationDate(e.target.value)} onFocus={handleInputFocus} placeholder={t('dateFormatPlaceholder')} className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 pr-10\" />\n                <button\n                  data-calendar-toggle\n                  onClick={(e) => openCalendar(e, 'creationDate')}\n                  className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-500 hover:text-indigo-600 transition-colors\"\n                  aria-label={t('openCalendar')}\n                >\n                  <CalendarIcon className=\"w-5 h-5\" />\n                </button>\n              </div>\n              {activeCalendar?.type === 'creationDate' && (\n                <Calendar\n                  initialDate={creationDate}\n                  onSelectDate={(date) => {\n                    setCreationDate(date);\n                    setActiveCalendar(null);\n                  }}\n                  onClose={() => setActiveCalendar(null)}\n                  showToday={true}\n                  position={activeCalendar.position}\n                />\n              )}\n            </div>\n\n            {/* Creator */}\n            <div className=\"w-36 flex-shrink-0\">\n              <label htmlFor=\"creatorName\" className=\"block text-sm font-medium text-gray-700 mb-1\">{t('creator')}</label>\n              <input\n                type=\"text\"\n                id=\"creatorName\"\n                value={creatorName}\n                onChange={e => setCreatorName(e.target.value)}\n                onFocus={handleInputFocus}\n                placeholder={t('creator')}\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500\"\n              />\n            </div>\n          </div>\n\n          {/* Project Start Date */}\n          <div className=\"relative\">\n            <label htmlFor=\"projectStart\" className=\"block text-sm font-medium text-gray-700 mb-1\">{t('projectStartDate')}</label>\n            <div className=\"relative\">\n              <input type=\"text\" id=\"projectStart\" value={projectStart} onChange={e => setProjectStart(e.target.value)} placeholder={t('dateFormatPlaceholder')} className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 pr-10\" />\n              <button\n                data-calendar-toggle\n                onClick={(e) => openCalendar(e, 'projectStart')}\n                className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-500 hover:text-indigo-600 transition-colors\"\n                aria-label={t('openCalendar')}\n              >\n                <CalendarIcon className=\"w-5 h-5\" />\n              </button>\n            </div>\n            {activeCalendar?.type === 'projectStart' && (\n              <Calendar\n                initialDate={projectStart}\n                onSelectDate={(date) => {\n                  setProjectStart(date);\n                  setActiveCalendar(null);\n                }}\n                onClose={() => setActiveCalendar(null)}\n                position={activeCalendar.position}\n              />\n            )}\n          </div>\n\n          {/* Project End Date and Add Task Button */}\n          <div className=\"flex items-end gap-2\">\n            <div className=\"relative flex-grow\">\n                <label htmlFor=\"projectEnd\" className=\"block text-sm font-medium text-gray-700 mb-1\">{t('projectEndDate')}</label>\n                <div className=\"relative\">\n                  <input type=\"text\" id=\"projectEnd\" value={projectEnd} onChange={e => setProjectEnd(e.target.value)} placeholder={t('dateFormatPlaceholder')} className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 pr-10\" />\n                  <button\n                    data-calendar-toggle\n                    onClick={(e) => openCalendar(e, 'projectEnd')}\n                    className=\"absolute inset-y-0 right-0 flex items-center pr-3 text-gray-500 hover:text-indigo-600 transition-colors\"\n                    aria-label={t('openCalendar')}\n                  >\n                    <CalendarIcon className=\"w-5 h-5\" />\n                  </button>\n                </div>\n                {activeCalendar?.type === 'projectEnd' && (\n                  <Calendar\n                    initialDate={projectEnd}\n                    onSelectDate={(date) => {\n                      setProjectEnd(date);\n                      setActiveCalendar(null);\n                    }}\n                    onClose={() => setActiveCalendar(null)}\n                    position={activeCalendar.position}\n                  />\n                )}\n            </div>\n            <button\n                onClick={onAddTask}\n                title={t('addTask')}\n                className=\"mb-[2px] w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all transform hover:scale-105\"\n            >\n                <PlusIcon className=\"w-6 h-6\" />\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <div ref={scrollContainerRef} className=\"relative overflow-auto flex-grow\">\n        <div\n          ref={ganttGridRef}\n          className=\"gantt-grid min-w-[1200px] grid relative\"\n          style={{\n            gridTemplateColumns: `auto 1fr`,\n            gridTemplateRows: `auto repeat(${tasks.length}, ${rowHeight}px)`,\n          }}\n        >\n          {/* Top-left corner */}\n          <div ref={taskDetailsHeaderRef} className=\"sticky top-0 left-0 bg-slate-100 p-2 border-b border-r border-gray-200 font-semibold text-slate-600 text-sm flex items-center z-30\">\n            <div className=\"flex items-center w-full gap-1\">\n              <div className=\"w-6 flex-shrink-0\" /> {/* Spacer for Grip Icon */}\n              <div className=\"flex-grow min-w-0 p-1\">{t('taskDetails')}</div>\n              {columnVisibility.assignee && <div className=\"w-24 flex-shrink-0 p-1 text-xs text-center\">{t('assignee')}</div>}\n              {columnVisibility.startDate && <div className=\"w-24 flex-shrink-0 p-1 text-xs text-center\">{t('startDate')}</div>}\n              {columnVisibility.endDate && <div className=\"w-24 flex-shrink-0 p-1 text-xs text-center\">{t('endDate')}</div>}\n              {columnVisibility.duration && <div className=\"w-16 flex-shrink-0 p-1 text-xs text-center\">{t('duration')}</div>}\n              {columnVisibility.progress && <div className=\"w-20 flex-shrink-0 p-1 text-xs text-center\">{t('progress')}</div>}\n              {columnVisibility.manHours && (\n                <div className=\"w-20 flex-shrink-0 p-1 text-xs text-center\">\n                  <div className=\"flex flex-col items-center justify-center -space-y-1\">\n                    <span>{t('manHours')}</span>\n                    <span className=\"text-[10px] text-slate-500 font-normal\">\n                      ({t('total')}: {totalManHours.toLocaleString(undefined, { maximumFractionDigits: 1 })})\n                    </span>\n                  </div>\n                </div>\n              )}\n              <div className=\"w-16 flex-shrink-0 flex items-center justify-end\">\n                 <button \n                    onClick={onDeleteAllTasks} \n                    className=\"text-gray-400 hover:text-red-500 p-1 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed\" \n                    title={t('deleteAllTasks')}\n                    disabled={tasks.length === 0}\n                  >\n                      <TrashIcon />\n                  </button>\n              </div>\n            </div>\n          </div>\n\n          {/* Date Headers */}\n          <div\n            className=\"sticky top-0 z-10 bg-slate-50 border-b border-gray-200\"\n            style={{\n              gridColumn: `2 / span 1`,\n            }}\n            ref={timelineHeaderRef}\n          >\n            <div className=\"grid\" style={{ gridTemplateColumns: `repeat(${dateArray.length}, ${dayWidth}px)` }}>\n              {monthHeaders.map((month, index) => (\n                <div key={index} className=\"text-center font-semibold text-slate-600 text-sm py-1 border-r border-gray-400\" style={{ gridColumn: `span ${month.days}` }}>\n                  {month.formatted}\n                </div>\n              ))}\n            </div>\n            <div className=\"grid\" style={{ gridTemplateColumns: `repeat(${dateArray.length}, ${dayWidth}px)` }}>\n              {dateHeaders.map(({ date, span, isLastDayOfMonth }, index) => {\n                const dayOfWeek = date.toLocaleString(language === 'ja' ? 'ja-JP' : 'en-US', { weekday: 'short', timeZone: 'UTC' });\n                const day = date.getUTCDay();\n                const isHoliday = holidays.has(day);\n\n                let dayColorClass = 'text-slate-500';\n                if (day === 0) { // Sunday\n                  dayColorClass = 'text-red-600';\n                } else if (day === 6) { // Saturday\n                  dayColorClass = 'text-blue-600';\n                }\n                \n                let borderClass = 'border-gray-200';\n                if (isLastDayOfMonth) {\n                  borderClass = 'border-gray-400';\n                } else if (span > 1) {\n                  borderClass = 'border-gray-300';\n                }\n                const containerAlignmentClass = span === 1 ? 'justify-center' : 'justify-start pl-1';\n                const textAlignmentClass = span === 1 ? 'items-center' : 'items-start';\n\n                return (\n                  <div \n                    key={index} \n                    className={`text-xs border-r ${borderClass} flex ${containerAlignmentClass} items-center h-full ${isHoliday ? 'bg-red-50' : 'bg-slate-50'} ${dayColorClass} overflow-hidden`}\n                    style={{ gridColumn: `span ${span}` }}\n                  >\n                      <div className={`flex flex-col ${textAlignmentClass} justify-center h-full`}>\n                        <span className=\"whitespace-nowrap leading-none\">{date.getUTCDate()}</span>\n                        <span className=\"text-[10px] leading-none whitespace-nowrap\">{dayOfWeek}</span>\n                      </div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n          \n          {typeof dropIndex === 'number' && reorderState && (\n            <div\n                className=\"h-0.5 bg-blue-500 pointer-events-none absolute w-full z-40\"\n                style={{\n                    top: (timelineHeaderRef.current?.offsetHeight || 0) + (tasks.findIndex(t => t.id === reorderState.draggedTaskId) < dropIndex ? dropIndex -1 : dropIndex) * rowHeight - 2,\n                    left: 0,\n                }}\n            />\n          )}\n\n          {/* Task Rows */}\n          {tasks.map((task, index) => {\n            const isDragging = reorderState?.draggedTaskId === task.id;\n            \n            return (\n            <React.Fragment key={task.id}>\n              {/* Task Details Column Cell */}\n              <div\n                ref={(el) => { taskRowRefs.current[task.id] = el; }}\n                className={`sticky left-0 bg-white border-b border-r border-gray-200 z-20 flex items-center p-2 gap-1 transition-opacity ${isDragging ? 'opacity-50' : ''}`}\n                style={{\n                  height: `${rowHeight}px`,\n                  gridRow: index + 2,\n                  gridColumn: 1,\n                  zIndex: activeCalendar?.taskId === task.id ? 41 : 20,\n                }}\n              >\n                  <button\n                    onMouseDown={(e) => handleReorderStart(e, task.id)}\n                    onTouchStart={(e) => handleReorderStart(e, task.id)}\n                    className=\"p-1 text-gray-400 hover:bg-gray-200 rounded-md\"\n                    title={t('reorderTask')}\n                  >\n                    <GripVerticalIcon className=\"w-5 h-5 cursor-grab active:cursor-grabbing\"/>\n                  </button>\n                  <input type=\"text\" value={task.name} onChange={e => onTaskChange(task.id, 'name', e.target.value)} onFocus={handleInputFocus} placeholder={t('taskNamePlaceholder')} className=\"flex-grow min-w-0 p-1 border-none focus:ring-0 text-sm\"/>\n                  {columnVisibility.assignee && <div className=\"w-24 flex-shrink-0\">\n                    <input\n                      type=\"text\"\n                      value={task.assignee || ''}\n                      onChange={e => onTaskChange(task.id, 'assignee', e.target.value)}\n                      onFocus={handleInputFocus}\n                      placeholder={t('assignee')}\n                      className=\"w-full p-1 border-none focus:ring-0 text-xs\"\n                    />\n                  </div>}\n                  {columnVisibility.startDate && <div className=\"relative w-24 flex-shrink-0\">\n                      <input type=\"text\" value={task.startDate} onChange={e => onTaskChange(task.id, 'startDate', e.target.value)} placeholder={t('dateFormatPlaceholder')} className=\"w-full p-1 border-none focus:ring-0 text-xs pr-6\"/>\n                      <button\n                          data-calendar-toggle\n                          onClick={(e) => openCalendar(e, 'taskStartDate', task.id)}\n                          className=\"absolute inset-y-0 right-0 flex items-center pr-1 text-gray-400 hover:text-indigo-600\"\n                          aria-label={t('openCalendar')}\n                      >\n                          <CalendarIcon className=\"w-4 h-4\"/>\n                      </button>\n                       {activeCalendar?.type === 'taskStartDate' && activeCalendar?.taskId === task.id && (\n                          <Calendar\n                              initialDate={task.startDate}\n                              taskStartDate={task.startDate}\n                              taskEndDate={task.endDate}\n                              minDate={projectStart}\n                              maxDate={task.endDate || projectEnd}\n                              onSelectDate={(date) => {\n                                  onTaskChange(task.id, 'startDate', date);\n                                  setActiveCalendar(null);\n                              }}\n                              onClose={() => setActiveCalendar(null)}\n                              position={activeCalendar.position}\n                          />\n                      )}\n                  </div>}\n                  {columnVisibility.endDate && <div className=\"relative w-24 flex-shrink-0\">\n                      <input type=\"text\" value={task.endDate} onChange={e => onTaskChange(task.id, 'endDate', e.target.value)} placeholder={t('dateFormatPlaceholder')} className=\"w-full p-1 border-none focus:ring-0 text-xs pr-6\"/>\n                      <button\n                          data-calendar-toggle\n                          onClick={(e) => openCalendar(e, 'taskEndDate', task.id)}\n                          className=\"absolute inset-y-0 right-0 flex items-center pr-1 text-gray-400 hover:text-indigo-600\"\n                          aria-label={t('openCalendar')}\n                      >\n                          <CalendarIcon className=\"w-4 h-4\"/>\n                      </button>\n                      {activeCalendar?.type === 'taskEndDate' && activeCalendar?.taskId === task.id && (\n                          <Calendar\n                              initialDate={task.endDate}\n                              taskStartDate={task.startDate}\n                              taskEndDate={task.endDate}\n                              minDate={task.startDate || projectStart}\n                              maxDate={projectEnd}\n                              onSelectDate={(date) => {\n                                  onTaskChange(task.id, 'endDate', date);\n                                  setActiveCalendar(null);\n                              }}\n                              onClose={() => setActiveCalendar(null)}\n                              position={activeCalendar.position}\n                          />\n                      )}\n                  </div>}\n                  {columnVisibility.duration && <div className=\"w-16 flex-shrink-0\">\n                    <input\n                      type=\"number\"\n                      value={getTaskDuration(task.startDate, task.endDate) || ''}\n                      onChange={e => onDurationChange(task, e.target.value)}\n                      onFocus={handleInputFocus}\n                      className=\"w-full p-1 border-none focus:ring-0 text-xs text-center\"\n                      placeholder=\"-\"\n                      min=\"1\"\n                    />\n                  </div>}\n                  {columnVisibility.progress && <div className=\"w-20 flex-shrink-0 relative\">\n                    <input\n                      type=\"number\"\n                      value={task.progress}\n                      onChange={e => onProgressChange(task.id, e.target.value)}\n                      onFocus={handleInputFocus}\n                      className=\"w-full p-1 border-none focus:ring-0 text-xs text-center pr-4\"\n                      min=\"0\"\n                      max=\"100\"\n                    />\n                    <span className=\"absolute right-2 top-1/2 -translate-y-1/2 text-xs text-gray-400\">%</span>\n                  </div>}\n                  {columnVisibility.manHours && <div className=\"w-20 flex-shrink-0\">\n                    <input\n                      type=\"number\"\n                      value={task.manHours ?? ''}\n                      onChange={e => onManHoursChange(task.id, e.target.value)}\n                      onFocus={handleInputFocus}\n                      className=\"w-full p-1 border-none focus:ring-0 text-xs text-center\"\n                      placeholder=\"-\"\n                      min=\"0\"\n                    />\n                  </div>}\n                  <div className=\"w-16 flex-shrink-0 flex items-center justify-end\">\n                    <button\n                      onClick={() => onDuplicateTask(task.id)}\n                      className=\"text-gray-400 hover:text-indigo-500 p-1 rounded-full transition-colors\"\n                      title={t('duplicateTask')}\n                    >\n                      <DuplicateIcon className=\"w-5 h-5\" />\n                    </button>\n                    <button onClick={() => onDeleteTask(task.id)} className=\"text-gray-400 hover:text-red-500 p-1 rounded-full transition-colors\">\n                        <TrashIcon />\n                    </button>\n                  </div>\n              </div>\n\n              {/* Task Timeline Row Cell */}\n              <div\n                className={`relative border-b transition-opacity z-0 ${isDragging ? 'opacity-50' : ''}`}\n                style={{\n                  gridRow: index + 2,\n                  gridColumn: `2 / span 1`,\n                }}\n                data-task-row-id={task.id}\n                onMouseDown={(e) => {\n                  if (!task.startDate && !task.endDate) {\n                    handlePointerDownForCreate(e);\n                  }\n                }}\n                onTouchStart={(e) => {\n                  if (!task.startDate && !task.endDate) {\n                    handlePointerDownForCreate(e);\n                  }\n                }}\n                onMouseMove={handlePointerMove}\n                onTouchMove={handlePointerMove}\n                onMouseLeave={handleMouseLeave}\n              >\n                  {/* Background Lines & Weekend Highlighting */}\n                  <div className=\"absolute inset-0 grid\" style={{ gridTemplateColumns: `repeat(${dateArray.length}, ${dayWidth}px)` }}>\n                      {dateArray.map((date, index) => {\n                          const isHoliday = holidays.has(date.getUTCDay());\n                          const nextDay = addDaysUTC(date, 1);\n                          const isLastDayOfMonth = nextDay.getUTCDate() === 1;\n\n                          let interval = 1;\n                          if (dayWidth < 24) interval = 2;\n                          if (dayWidth < 18) interval = 3;\n                          if (dayWidth < 12) interval = 7;\n                          const isGroupSeparator = interval > 1 && (index + 1) % interval === 0;\n\n                          let borderClass = 'border-gray-100'; // Lightest, default\n                          if (isLastDayOfMonth) {\n                              borderClass = 'border-gray-400'; // Darkest\n                          } else if (isGroupSeparator) {\n                              borderClass = 'border-gray-300'; // Medium\n                          }\n                          return <div key={index} className={`h-full border-r ${borderClass} ${isHoliday ? 'bg-red-50' : ''}`}></div>;\n                      })}\n                  </div>\n                  {/* Task Bar */}\n                  <div className=\"absolute inset-0 grid items-center\" style={{ gridTemplateColumns: `repeat(${dateArray.length}, ${dayWidth}px)` }}>\n                     {(() => {\n                        const taskStart = parseUTCDateString(task.startDate);\n                        const taskEnd = parseUTCDateString(task.endDate);\n\n                        if (!taskStart || !taskEnd || taskEnd < taskStart) {\n                            return null;\n                        }\n\n                        const totalWorkingDays = getTaskDuration(task.startDate, task.endDate);\n                        if (totalWorkingDays === 0) return null;\n                        \n                        let completedWorkingDays = totalWorkingDays * (task.progress / 100);\n                        const lightningSvg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" class=\"w-5 h-5\"><path fill-rule=\"evenodd\" d=\"M11.933 3.339a.75.75 0 01.328 1.309l-6 7.5a.75.75 0 01-1.261-.548l2.25-9.75a.75.75 0 011.355-.26l2.328 1.75Z\" clip-rule=\"evenodd\" /><path d=\"M4.583 8.883c.31.043.614.12.906.224l-2.25 9.75a.75.75 0 01-1.355.26L.182 17.367a.75.75 0 01.26-1.025l4.14-1.453Z\" /><path d=\"M12.75 11.25a.75.75 0 01.75-.75h4.5a.75.75 0 010 1.5h-4.5a.75.75 0 01-.75-.75Z\" /></svg>`;\n                        const lightningDataUrl = `url(\"data:image/svg+xml;base64,${btoa(lightningSvg.replace('<svg ', `<svg fill='rgba(31, 41, 55, 0.4)' `))}\")`;\n                        \n                        const totalDurationDays = (taskEnd.getTime() - taskStart.getTime()) / (1000 * 3600 * 24) + 1;\n                        if (totalDurationDays <= 0) return null;\n                        \n                        const segments = getTaskSegments(task);\n\n                        const interactionLayerStyle: React.CSSProperties = { color: textColor };\n                        if (segments.length > 0 && totalDurationDays > 0) {\n                            const visualStartDate = segments[0].startDate;\n                            const visualEndDate = segments[segments.length - 1].endDate;\n\n                            const startOffsetDays = (visualStartDate.getTime() - taskStart.getTime()) / (1000 * 3600 * 24);\n                            const endOffsetDays = (taskEnd.getTime() - visualEndDate.getTime()) / (1000 * 3600 * 24);\n                            \n                            interactionLayerStyle.position = 'absolute';\n                            interactionLayerStyle.top = '0';\n                            interactionLayerStyle.bottom = '0';\n                            interactionLayerStyle.left = `${(startOffsetDays / totalDurationDays) * 100}%`;\n                            interactionLayerStyle.right = `${(endOffsetDays / totalDurationDays) * 100}%`;\n                        } else {\n                            interactionLayerStyle.display = 'none';\n                        }\n\n\n                        return (\n                            <div\n                                className=\"relative h-8\"\n                                style={{ ...getGridPosition(taskStart, taskEnd) }}\n                            >\n                                {/* Background Visual Bars Container */}\n                                <div className=\"absolute inset-0\">\n                                    {segments.map((segment, segIndex) => {\n                                        const segmentWorkingDays = calculateWorkingDays(segment.startDate, segment.endDate, holidays);\n                                        if (segmentWorkingDays === 0) return null;\n\n                                        const progressDaysInSegment = Math.max(0, Math.min(segmentWorkingDays, completedWorkingDays));\n                                        const progressWidthPercent = (progressDaysInSegment / segmentWorkingDays) * 100;\n                                        completedWorkingDays -= progressDaysInSegment;\n\n                                        const segmentStartOffsetDays = (segment.startDate.getTime() - taskStart.getTime()) / (1000 * 3600 * 24);\n                                        const segmentDurationDays = (segment.endDate.getTime() - segment.startDate.getTime()) / (1000 * 3600 * 24) + 1;\n                                        \n                                        const left = (segmentStartOffsetDays / totalDurationDays) * 100;\n                                        const width = (segmentDurationDays / totalDurationDays) * 100;\n                                        \n                                        return (\n                                            <div\n                                                key={`segment-${segIndex}`}\n                                                className=\"absolute top-0 h-full\"\n                                                style={{ left: `${left}%`, width: `${width}%` }}\n                                            >\n                                                <div className=\"w-full h-full relative\" style={{ backgroundColor: baseColor }}>\n                                                    <div\n                                                        className=\"absolute top-0 left-0 h-full pointer-events-none\"\n                                                        style={{ \n                                                            width: `${progressWidthPercent}%`, \n                                                            backgroundColor: progressColor,\n                                                            backgroundImage: lightningDataUrl,\n                                                            backgroundSize: '16px',\n                                                        }}\n                                                    />\n                                                </div>\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n\n                                {/* Foreground Interaction & Text Layer */}\n                                <div\n                                    className=\"group/bar cursor-move px-3 text-sm font-medium flex items-center\"\n                                    style={{ ...interactionLayerStyle, touchAction: 'none' }}\n                                    onMouseDown={(e) => handleDragStart(e, task, 'move')}\n                                    onTouchStart={(e) => handleDragStart(e, task, 'move')}\n                                >\n                                    <span className=\"whitespace-nowrap\">{task.name}</span>\n                                    <div\n                                        className=\"absolute left-0 top-0 h-full w-2 cursor-ew-resize\"\n                                        onMouseDown={(e) => handleDragStart(e, task, 'resize-start')}\n                                        onTouchStart={(e) => handleDragStart(e, task, 'resize-start')}\n                                    />\n                                    <div\n                                        className=\"absolute right-0 top-0 h-full w-2 cursor-ew-resize\"\n                                        onMouseDown={(e) => handleDragStart(e, task, 'resize-end')}\n                                        onTouchStart={(e) => handleDragStart(e, task, 'resize-end')}\n                                    />\n                                </div>\n                            </div>\n                        );\n                     })()}\n                     {dragPreview && dragPreview.taskId === task.id && (\n                        <div\n                          className=\"h-8 bg-indigo-300 opacity-70\"\n                          style={getGridPosition(\n                              parseUTCDateString(dragPreview.start > dragPreview.end ? dragPreview.end : dragPreview.start)!,\n                              parseUTCDateString(dragPreview.start > dragPreview.end ? dragPreview.start : dragPreview.end)!,\n                          )}\n                        />\n                     )}\n                  </div>\n              </div>\n            </React.Fragment>\n          )})}\n          {progressLinePath && (\n            <div className=\"absolute top-0 left-0 pointer-events-none z-35\" style={{ height: totalContentHeight, width: totalGridWidth ? `${totalGridWidth}px` : '100%' }}>\n              <svg width={totalGridWidth || '100%'} height=\"100%\">\n                  <path d={progressLinePath} stroke={progressLineColor} strokeWidth=\"2\" fill=\"none\" strokeDasharray=\"4 4\" />\n              </svg>\n            </div>\n          )}\n        </div>\n      </div>\n      <button\n        onClick={onAddTask}\n        title={t('addTask')}\n        className=\"fixed bottom-8 right-8 z-50 w-14 h-14 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all transform hover:scale-110\"\n      >\n        <PlusIcon className=\"w-7 h-7\" />\n      </button>\n    </div>\n  );\n};\n\nexport default GanttChart;"
            }
          ]
        }
      ]
    },
    "createdTimestamp": {
      "seconds": 1770605261,
      "nanos": 149000000
    },
    "doneTimestamp": {
      "seconds": 1770605369,
      "nanos": 124000000
    }
  }
]